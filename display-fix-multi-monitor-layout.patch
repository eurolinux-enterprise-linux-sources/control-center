From 38318c7e6fdc8e4035cb75f13a1e66ea3e05eebc Mon Sep 17 00:00:00 2001
From: Rui Matos <tiagomatos@gmail.com>
Date: Mon, 13 Nov 2017 17:28:44 +0100
Subject: [PATCH 1/2] display: Remove automatic layout adjustments

As the comment hinted at, fixing layouts automatically to ensure their
applicability doesn't actually work in all cases and in fact may force
users to redo their layout completely after a seemingly small change.

So, let's stop pretending we can do it and instead leave it to users
to fix it manually.

https://bugzilla.gnome.org/show_bug.cgi?id=789711
---
 panels/display/cc-display-config-dbus.c | 89 ---------------------------------
 1 file changed, 89 deletions(-)

diff --git a/panels/display/cc-display-config-dbus.c b/panels/display/cc-display-config-dbus.c
index 48e0145ee..26dbcdf45 100644
--- a/panels/display/cc-display-config-dbus.c
+++ b/panels/display/cc-display-config-dbus.c
@@ -331,8 +331,6 @@ static void
 cc_display_config_dbus_append_right (CcDisplayConfigDBus *self,
                                      CcDisplayLogicalMonitor *monitor);
 static void
-cc_display_config_dbus_ensure_gapless (CcDisplayConfigDBus *self);
-static void
 cc_display_config_dbus_make_linear (CcDisplayConfigDBus *self);
 
 
@@ -447,7 +445,6 @@ cc_display_monitor_dbus_set_active (CcDisplayMonitor *pself,
   else if (self->logical_monitor && !active)
     {
       cc_display_monitor_dbus_set_logical_monitor (self, NULL);
-      cc_display_config_dbus_ensure_gapless (self->config);
     }
 
   g_signal_emit_by_name (self, "active");
@@ -476,9 +473,6 @@ cc_display_monitor_dbus_set_rotation (CcDisplayMonitor *pself,
   if (self->logical_monitor->rotation != rotation)
     {
       self->logical_monitor->rotation = rotation;
-      /* See comment in ensure_gapless() for why we disregard the
-         existing layout here. */
-      cc_display_config_dbus_make_linear (self->config);
 
       g_signal_emit_by_name (self, "rotation");
     }
@@ -644,28 +638,13 @@ cc_display_monitor_dbus_set_mode (CcDisplayMonitor *pself,
 {
   CcDisplayMonitorDBus *self = CC_DISPLAY_MONITOR_DBUS (pself);
   CcDisplayMode *mode;
-  int w1, w2, h1, h2;
 
   g_return_if_fail (new_mode != NULL);
 
-  if (self->current_mode)
-    cc_display_mode_get_resolution (self->current_mode, &w1, &h1);
-  else
-    w1 = h1 = 0;
-
   mode = cc_display_monitor_dbus_get_closest_mode (self, CC_DISPLAY_MODE_DBUS (new_mode));
-  if (mode)
-    cc_display_mode_get_resolution (mode, &w2, &h2);
-  else
-    w2 = h2 = 0;
 
   self->current_mode = mode;
 
-  /* See comment in ensure_gapless() for why we disregard the
-     existing layout here. */
-  if (w1 != w2 || h1 != h2)
-    cc_display_config_dbus_make_linear (self->config);
-
   if (!cc_display_mode_dbus_is_supported_scale (mode, cc_display_monitor_get_scale (pself)))
     cc_display_monitor_set_scale (pself, cc_display_mode_get_preferred_scale (mode));
 
@@ -714,9 +693,6 @@ cc_display_monitor_dbus_set_scale (CcDisplayMonitor *pself,
   if (self->logical_monitor->scale != scale)
     {
       self->logical_monitor->scale = scale;
-      /* See comment in ensure_gapless() for why we disregard the
-         existing layout here. */
-      cc_display_config_dbus_make_linear (self->config);
 
       g_signal_emit_by_name (self, "scale");
     }
@@ -1553,28 +1529,6 @@ add_y_delta (gpointer d1, gpointer d2)
   m->y += delta;
 }
 
-static int
-logical_monitor_height (CcDisplayLogicalMonitor *lm)
-{
-  CcDisplayMonitorDBus *monitor;
-  CcDisplayModeDBus *mode;
-  GHashTableIter iter;
-  int height;
-
-  g_hash_table_iter_init (&iter, lm->monitors);
-  g_hash_table_iter_next (&iter, (void **) &monitor, NULL);
-  mode = CC_DISPLAY_MODE_DBUS (monitor->current_mode);
-  if (logical_monitor_is_rotated (lm))
-    height = mode ? mode->width : 0;
-  else
-    height = mode ? mode->height : 0;
-
-  if (monitor->config->layout_mode == CC_DISPLAY_LAYOUT_MODE_LOGICAL)
-    return round (height / lm->scale);
-  else
-    return height;
-}
-
 static void
 cc_display_config_dbus_ensure_non_offset_coords (CcDisplayConfigDBus *self)
 {
@@ -1624,49 +1578,6 @@ cc_display_config_dbus_append_right (CcDisplayConfigDBus *self,
   g_list_free (x_axis);
 }
 
-static void
-cc_display_config_dbus_ensure_gapless (CcDisplayConfigDBus *self)
-{
-  GList *x_axis, *y_axis, *l;
-
-  if (g_hash_table_size (self->logical_monitors) == 0)
-    return;
-
-  x_axis = g_hash_table_get_keys (self->logical_monitors);
-  x_axis = g_list_sort (x_axis, sort_x_axis);
-  y_axis = g_hash_table_get_keys (self->logical_monitors);
-  y_axis = g_list_sort (y_axis, sort_y_axis);
-
-  /* This might produce overlaps which will fail validation.
-     Unfortunately, automating this to avoid gaps and overlaps with
-     arbitrary rectangles is a hard problem and we'd probably not find
-     the layout the user wants anyway. We'll need a panel re-design
-     that allows manual layout adjustments after monitor operations
-     and before applying. */
-  for (l = x_axis; l != NULL && l->next != NULL; l = l->next)
-    {
-      CcDisplayLogicalMonitor *m = l->data;
-      CcDisplayLogicalMonitor *n = l->next->data;
-      int mx2 = m->x + logical_monitor_width (m);
-
-      if (n->x > mx2)
-        n->x = mx2;
-    }
-
-  for (l = y_axis; l != NULL && l->next != NULL; l = l->next)
-    {
-      CcDisplayLogicalMonitor *m = l->data;
-      CcDisplayLogicalMonitor *n = l->next->data;
-      int my2 = m->y + logical_monitor_height (m);
-
-      if (n->y > my2)
-        n->y = my2;
-    }
-
-  g_list_free (x_axis);
-  g_list_free (y_axis);
-}
-
 static void
 cc_display_config_dbus_make_linear (CcDisplayConfigDBus *self)
 {
-- 
2.14.2

From 377f1effdd2c04005024cb621993b0175ea009ac Mon Sep 17 00:00:00 2001
From: Rui Matos <tiagomatos@gmail.com>
Date: Tue, 14 Nov 2017 17:02:39 +0100
Subject: [PATCH 2/2] display: Ignore disabled and closed builtin panels in
 layout geometry

Extend the existing checks for this kind of outputs to the layout
geometry routines.
---
 panels/display/cc-display-panel.c | 90 +++++++++++++++++++++++++--------------
 1 file changed, 58 insertions(+), 32 deletions(-)

diff --git a/panels/display/cc-display-panel.c b/panels/display/cc-display-panel.c
index 32e5102de..071e98689 100644
--- a/panels/display/cc-display-panel.c
+++ b/panels/display/cc-display-panel.c
@@ -144,13 +144,13 @@ make_output_ui_name (CcDisplayMonitor *output)
 }
 
 static void
-ensure_output_numbers (CcDisplayConfig *config)
+ensure_output_numbers (CcDisplayPanel *self)
 {
   GList *outputs, *l;
   GList *sorted = NULL;
   gint n = 0;
 
-  outputs = cc_display_config_get_monitors (config);
+  outputs = cc_display_config_get_monitors (self->priv->current_config);
 
   for (l = outputs; l != NULL; l = l->next)
     {
@@ -165,15 +165,20 @@ ensure_output_numbers (CcDisplayConfig *config)
     {
       CcDisplayMonitor *output = l->data;
       gchar *ui_name = make_output_ui_name (output);
+      gboolean lid_is_closed = (cc_display_monitor_is_builtin (output) &&
+                                self->priv->lid_is_closed);
 
       g_object_set_data (G_OBJECT (output), "ui-number", GINT_TO_POINTER (++n));
       g_object_set_data_full (G_OBJECT (output), "ui-number-name",
                               g_strdup_printf ("%d\u2003%s", n, ui_name),
                               g_free);
       g_object_set_data_full (G_OBJECT (output), "ui-name", ui_name, g_free);
+
+      g_object_set_data (G_OBJECT (output), "lid-is-closed", GINT_TO_POINTER (lid_is_closed));
     }
 
-  g_object_set_data_full (G_OBJECT (config), "ui-sorted-outputs", sorted, (GDestroyNotify) g_list_free);
+  g_object_set_data_full (G_OBJECT (self->priv->current_config), "ui-sorted-outputs",
+                          sorted, (GDestroyNotify) g_list_free);
 }
 
 static void
@@ -1397,6 +1402,32 @@ make_arrangement_row (CcDisplayPanel *panel)
   return row;
 }
 
+static gboolean
+is_output_useful (CcDisplayMonitor *output)
+{
+  return (cc_display_monitor_is_active (output) &&
+          !g_object_get_data (G_OBJECT (output), "lid-is-closed"));
+}
+
+static guint
+count_useful_outputs (CcDisplayPanel *panel)
+{
+  CcDisplayPanelPrivate *priv = panel->priv;
+  GList *outputs, *l;
+  guint active = 0;
+
+  outputs = cc_display_config_get_monitors (priv->current_config);
+  for (l = outputs; l != NULL; l = l->next)
+    {
+      CcDisplayMonitor *output = l->data;
+      if (!is_output_useful (output))
+        continue;
+      else
+        active++;
+    }
+  return active;
+}
+
 static void
 primary_label_sync (GtkWidget       *label,
                     CcDisplayConfig *config)
@@ -1465,6 +1496,9 @@ show_primary_chooser_dialog (CcDisplayPanel *panel)
       GtkWidget *row, *check;
       gchar *text;
 
+      if (!is_output_useful (output))
+        continue;
+
       check = gtk_image_new ();
       gtk_image_set_from_icon_name (GTK_IMAGE (check), "object-select-symbolic", GTK_ICON_SIZE_MENU);
       if (!cc_display_monitor_is_primary (output))
@@ -1518,26 +1552,6 @@ replace_current_output_ui (GtkWidget      *frame,
   g_clear_object (&priv->rows_size_group);
 }
 
-static guint
-count_active_outputs (CcDisplayPanel *panel)
-{
-  CcDisplayPanelPrivate *priv = panel->priv;
-  GList *outputs, *l;
-  guint active = 0;
-
-  outputs = cc_display_config_get_monitors (priv->current_config);
-  for (l = outputs; l != NULL; l = l->next)
-    {
-      CcDisplayMonitor *output = l->data;
-      if (!cc_display_monitor_is_active (output) ||
-          (cc_display_monitor_is_builtin (output) && priv->lid_is_closed))
-        continue;
-      else
-        active++;
-    }
-  return active;
-}
-
 static GtkWidget *
 make_arrangement_ui (CcDisplayPanel *panel)
 {
@@ -2015,7 +2029,7 @@ make_two_output_ui (CcDisplayPanel *panel)
 
   if (cc_display_config_is_cloning (priv->current_config) && show_mirror)
     gtk_stack_set_visible_child_name (GTK_STACK (stack), "mirror");
-  else if (count_active_outputs (panel) > 1)
+  else if (count_useful_outputs (panel) > 1)
     gtk_stack_set_visible_child_name (GTK_STACK (stack), "join");
   else
     gtk_stack_set_visible_child_name (GTK_STACK (stack), "single");
@@ -2052,7 +2066,7 @@ make_output_switch (CcDisplayPanel *panel)
                            button, G_CONNECT_SWAPPED);
   output_switch_sync (button, priv->current_output);
 
-  if ((count_active_outputs (panel) < 2 && cc_display_monitor_is_active (priv->current_output)) ||
+  if ((count_useful_outputs (panel) < 2 && cc_display_monitor_is_active (priv->current_output)) ||
       (cc_display_monitor_is_builtin (priv->current_output) && priv->lid_is_closed))
     gtk_widget_set_sensitive (button, FALSE);
 
@@ -2197,7 +2211,7 @@ on_screen_changed (CcDisplayPanel *panel)
 
   priv->current_config = current;
 
-  ensure_output_numbers (current);
+  ensure_output_numbers (panel);
   ensure_monitor_labels (panel);
 
   priv->current_output = NULL;
@@ -2206,8 +2220,7 @@ on_screen_changed (CcDisplayPanel *panel)
     {
       CcDisplayMonitor *output = l->data;
 
-      if (!cc_display_monitor_is_active (output) ||
-          (cc_display_monitor_is_builtin (output) && priv->lid_is_closed))
+      if (!is_output_useful (output))
         continue;
 
       priv->current_output = output;
@@ -2261,6 +2274,9 @@ get_total_size (CcDisplayPanel *self, int *total_w, int *total_h)
       CcDisplayMonitor *output = l->data;
       int w, h;
 
+      if (!is_output_useful (output))
+        continue;
+
       get_geometry (output, NULL, NULL, &w, &h);
 
       if (cc_display_config_is_layout_logical (self->priv->current_config))
@@ -2287,7 +2303,7 @@ compute_scale (CcDisplayPanel *self, FooScrollArea *area)
 
   get_total_size (self, &total_w, &total_h);
 
-  n_monitors = g_list_length (cc_display_config_get_monitors (self->priv->current_config));
+  n_monitors = count_useful_outputs (self);
 
   available_w = viewport.width - 2 * MARGIN - (n_monitors - 1) * SPACE;
   available_h = viewport.height - 2 * MARGIN - (n_monitors - 1) * SPACE;
@@ -2357,6 +2373,9 @@ list_edges (CcDisplayPanel *panel, GArray *edges)
     {
       CcDisplayMonitor *output = l->data;
 
+      if (!is_output_useful (output))
+        continue;
+
       list_edges_for_output (output, edges, should_scale);
     }
 }
@@ -2562,6 +2581,10 @@ output_overlaps (CcDisplayMonitor *output, CcDisplayPanel *panel)
   for (l = outputs; l != NULL; l = l->next)
     {
       CcDisplayMonitor *o = l->data;
+
+      if (!is_output_useful (o))
+        continue;
+
       if (o != output)
 	{
 	  GdkRectangle other_rect;
@@ -2584,6 +2607,10 @@ config_is_aligned (CcDisplayPanel *panel, GArray *edges)
   for (l = outputs; l != NULL; l = l->next)
     {
       CcDisplayMonitor *output = l->data;
+
+      if (!is_output_useful (output))
+        continue;
+
       if (!output_is_aligned (output, edges))
         return FALSE;
 
@@ -2767,7 +2794,7 @@ on_output_event (FooScrollArea *area,
       return;
     }
 
-  n_monitors = g_list_length (cc_display_config_get_monitors (self->priv->current_config));
+  n_monitors = count_useful_outputs (self);
 
   /* If the mouse is inside the outputs, set the cursor to "you can move me".  See
    * on_canvas_event() for where we reset the cursor to the default if it
@@ -2929,8 +2956,7 @@ on_area_paint (FooScrollArea  *area,
       CcDisplayMonitor *output = list->data;
       GdkRectangle viewport;
 
-      if (!cc_display_monitor_is_active (output) ||
-          (cc_display_monitor_is_builtin (output) && self->priv->lid_is_closed))
+      if (!is_output_useful (output))
         continue;
 
       cairo_save (cr);
-- 
2.14.2

