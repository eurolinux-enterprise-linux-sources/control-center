From f8210aeb65f597c03c6ea54da0b444187618181b Mon Sep 17 00:00:00 2001
From: Ondrej Holy <oholy@redhat.com>
Date: Tue, 5 Dec 2017 16:22:29 +0100
Subject: [PATCH 1/2] user-accounts: Prevent crashes if current user is not in
 carousel

In a specific cases, current user doesn't have to be returned from
accountsservice, or can be skipped by act_user_is_system_account check.
System users should not be shown. This is expected for root account,
but should not happen with regular user accounts. It needs to be fixed
in accountsservice if you see this happening with regular user accounts.
We have to be just sure that Users panel doesn't crash in such cases
and show all non-system user accounts returned from accountsservice.
Empty page is shown currently only if act_user_manager_list_users
returns nothing, but it has to be also shown if only system accounts
are returned. To fix this issue, do not try to show current user, but
show first user account in carousel instead if there is any. First user
account is current user in normal case.

The patch also fixes problems that current user account is sometimes
selected instead of currently selected user account. This is because
of preselection of first item in um_carousel_add, which causes unwanted
signal emissions...

https://bugzilla.gnome.org/show_bug.cgi?id=773673
---
 panels/user-accounts/um-carousel.c   | 19 ++++++++++++----
 panels/user-accounts/um-carousel.h   |  2 ++
 panels/user-accounts/um-user-panel.c | 44 ++++++++++--------------------------
 3 files changed, 29 insertions(+), 36 deletions(-)

diff --git a/panels/user-accounts/um-carousel.c b/panels/user-accounts/um-carousel.c
index f7d0a26b0..78b5d5f94 100644
--- a/panels/user-accounts/um-carousel.c
+++ b/panels/user-accounts/um-carousel.c
@@ -175,60 +175,69 @@ um_carousel_find_item (UmCarousel    *self,
         GList *list;
 
         list = self->children;
         while (list != NULL)
         {
                 if (!func (list->data, data))
                         return list->data;
                 list = list->next;
         }
 
         return NULL;
 }
 
 static void
 on_item_toggled (UmCarouselItem *item,
                  GdkEvent       *event,
                  gpointer        user_data)
 {
         UmCarousel *self = UM_CAROUSEL (user_data);
 
         um_carousel_select_item (self, item);
 }
 
 void
 um_carousel_select_item (UmCarousel     *self,
                          UmCarouselItem *item)
 {
         gchar *page_name;
         gboolean page_changed = TRUE;
 
+        /* Select first user if none is specified */
+        if (item == NULL)
+        {
+                if (self->children != NULL)
+                        item = self->children->data;
+                else
+                        return;
+        }
+
         if (self->selected_item != NULL)
         {
                 page_changed = (self->selected_item->page != item->page);
                 self->arrow_start_x = um_carousel_item_get_x (self->selected_item, self);
         }
 
         self->selected_item = item;
         self->visible_page = item->page;
         g_signal_emit (self, signals[ITEM_ACTIVATED], 0, item);
 
         if (!page_changed)
         {
                 um_carousel_move_arrow (self);
                 return;
         }
 
         page_name = g_strdup_printf ("%d", self->visible_page);
         gtk_stack_set_visible_child_name (self->stack, page_name);
 
         g_free (page_name);
 
         update_buttons_visibility (self);
 
         /* um_carousel_move_arrow is called from on_transition_running */
 }
 
 static void
 um_carousel_select_item_at_index (UmCarousel *self,
                                   gint        index)
 {
@@ -277,64 +286,60 @@ um_carousel_add (GtkContainer *container,
         gboolean last_box_is_full;
 
         if (!UM_IS_CAROUSEL_ITEM (widget)) {
                 GTK_CONTAINER_CLASS (um_carousel_parent_class)->add (container, widget);
                 return;
         }
 
         gtk_style_context_add_class (gtk_widget_get_style_context (widget), "menu");
         gtk_button_set_relief (GTK_BUTTON (widget), GTK_RELIEF_NONE);
 
         self->children = g_list_append (self->children, widget);
         UM_CAROUSEL_ITEM (widget)->page = get_last_page_number (self);
         if (self->selected_item != NULL)
                 gtk_radio_button_join_group (GTK_RADIO_BUTTON (widget), GTK_RADIO_BUTTON (self->selected_item));
         g_signal_connect (widget, "button-press-event", G_CALLBACK (on_item_toggled), self);
 
         last_box_is_full = ((g_list_length (self->children) - 1) % ITEMS_PER_PAGE == 0);
         if (last_box_is_full) {
                 gchar *page;
 
                 page = g_strdup_printf ("%d", UM_CAROUSEL_ITEM (widget)->page);
                 self->last_box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
                 gtk_widget_set_valign (self->last_box, GTK_ALIGN_CENTER);
                 gtk_stack_add_named (self->stack, self->last_box, page);
         }
 
         gtk_box_pack_start (GTK_BOX (self->last_box), widget, TRUE, FALSE, 10);
         gtk_widget_show_all (self->last_box);
 
         update_buttons_visibility (self);
-
-        /* If there's only one child, select it. */
-        if (self->children->next == NULL)
-                um_carousel_select_item_at_index (self, 0);
 }
 
 void
 um_carousel_purge_items (UmCarousel *self)
 {
         gtk_container_forall (GTK_CONTAINER (self->stack),
                               (GtkCallback) gtk_widget_destroy,
                               NULL);
 
         g_list_free (self->children);
         self->children = NULL;
         self->visible_page = 0;
         self->selected_item = NULL;
 }
 
 UmCarousel *
 um_carousel_new (void)
 {
         return g_object_new (UM_TYPE_CAROUSEL, NULL);
 }
 
 static void
 um_carousel_class_init (UmCarouselClass *klass)
 {
         GtkWidgetClass *wclass = GTK_WIDGET_CLASS (klass);
         GtkContainerClass *container_class = GTK_CONTAINER_CLASS (klass);
 
         gtk_widget_class_set_template_from_resource (wclass,
                                                      "/org/gnome/control-center/user-accounts/carousel.ui");
 
@@ -371,30 +376,36 @@ on_size_allocate (UmCarousel *self)
        um_carousel_move_arrow (self);
 }
 
 static void
 on_transition_running (UmCarousel *self)
 {
         if (!gtk_stack_get_transition_running (self->stack))
                 um_carousel_move_arrow (self);
 }
 
 static void
 um_carousel_init (UmCarousel *self)
 {
         GtkStyleProvider *provider;
 
         gtk_widget_init_template (GTK_WIDGET (self));
 
         provider = GTK_STYLE_PROVIDER (gtk_css_provider_new ());
         gtk_css_provider_load_from_resource (GTK_CSS_PROVIDER (provider),
                                              "/org/gnome/control-center/user-accounts/carousel.css");
 
         gtk_style_context_add_provider_for_screen (gdk_screen_get_default (),
                                                    provider,
                                                    GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
 
         g_object_unref (provider);
 
         g_signal_connect_swapped (self->stack, "size-allocate", G_CALLBACK (on_size_allocate), self);
         g_signal_connect_swapped (self->stack, "notify::transition-running", G_CALLBACK (on_transition_running), self);
 }
+
+guint
+um_carousel_get_item_count (UmCarousel *self)
+{
+        return g_list_length (self->children);
+}
diff --git a/panels/user-accounts/um-carousel.h b/panels/user-accounts/um-carousel.h
index 0812ca3ba..731e1c7bd 100644
--- a/panels/user-accounts/um-carousel.h
+++ b/panels/user-accounts/um-carousel.h
@@ -19,33 +19,35 @@
  */
 
 #ifndef UM_CAROUSEL_H
 #define UM_CAROUSEL_H
 
 #include <gtk/gtk.h>
 
 G_BEGIN_DECLS
 
 #define UM_TYPE_CAROUSEL_ITEM (um_carousel_item_get_type ())
 
 G_DECLARE_FINAL_TYPE (UmCarouselItem, um_carousel_item, UM, CAROUSEL_ITEM, GtkRadioButton)
 
 #define UM_TYPE_CAROUSEL (um_carousel_get_type())
 
 G_DECLARE_FINAL_TYPE (UmCarousel, um_carousel, UM, CAROUSEL, GtkRevealer)
 
 GtkWidget       *um_carousel_item_new    (void);
 
 UmCarousel      *um_carousel_new         (void);
 
 void             um_carousel_purge_items (UmCarousel     *self);
 
 UmCarouselItem  *um_carousel_find_item   (UmCarousel     *self,
                                           gconstpointer   data,
                                           GCompareFunc    func);
 
 void             um_carousel_select_item (UmCarousel     *self,
                                           UmCarouselItem *item);
 
+guint            um_carousel_get_item_count (UmCarousel  *self);
+
 G_END_DECLS
 
 #endif /* UM_CAROUSEL_H */
diff --git a/panels/user-accounts/um-user-panel.c b/panels/user-accounts/um-user-panel.c
index c1875cb69..4e7009f28 100644
--- a/panels/user-accounts/um-user-panel.c
+++ b/panels/user-accounts/um-user-panel.c
@@ -206,173 +206,158 @@ create_carousel_entry (CcUserPanelPrivate *d, ActUser *user)
 
         return box;
 }
 
 static void
 user_added (ActUserManager *um, ActUser *user, CcUserPanelPrivate *d)
 {
         GtkWidget *item, *widget;
         gboolean show_carousel;
 
         if (act_user_is_system_account (user)) {
                 return;
         }
 
         g_debug ("user added: %d %s\n", act_user_get_uid (user), get_real_or_user_name (user));
 
         widget = create_carousel_entry (d, user);
         item = um_carousel_item_new ();
         gtk_container_add (GTK_CONTAINER (item), widget);
 
         g_object_set_data (G_OBJECT (item), "uid", GINT_TO_POINTER (act_user_get_uid (user)));
         gtk_container_add (GTK_CONTAINER (d->carousel), item);
 
         if (act_user_get_uid (user) != getuid ()) {
                 d->other_accounts++;
         }
 
         /* Show heading for other accounts if new one have been added. */
         show_carousel = (d->other_accounts > 0);
         gtk_revealer_set_reveal_child (GTK_REVEALER (d->carousel), show_carousel);
+
+        gtk_stack_set_visible_child_name (GTK_STACK (d->stack), PAGE_USERS);
 }
 
 static gint
 sort_users (gconstpointer a, gconstpointer b)
 {
         ActUser *ua, *ub;
         gchar *name1, *name2;
         gint result;
 
         ua = ACT_USER (a);
         ub = ACT_USER (b);
 
         /* Make sure the current user is shown first */
         if (act_user_get_uid (ua) == getuid ()) {
                 result = -G_MAXINT32;
         }
         else if (act_user_get_uid (ub) == getuid ()) {
                 result = G_MAXINT32;
         }
         else {
                 name1 = g_utf8_collate_key (get_real_or_user_name (ua), -1);
                 name2 = g_utf8_collate_key (get_real_or_user_name (ub), -1);
 
                 result = strcmp (name1, name2);
 
                 g_free (name1);
                 g_free (name2);
         }
 
         return result;
 }
 
 static void
 reload_users (CcUserPanelPrivate *d, ActUser *selected_user)
 {
         ActUser *user;
         GSList *list, *l;
-        UmCarouselItem *item;
+        UmCarouselItem *item = NULL;
         GtkSettings *settings;
         gboolean animations;
 
         settings = gtk_settings_get_default ();
 
         g_object_get (settings, "gtk-enable-animations", &animations, NULL);
         g_object_set (settings, "gtk-enable-animations", FALSE, NULL);
 
         um_carousel_purge_items (d->carousel);
-
         d->other_accounts = 0;
 
         list = act_user_manager_list_users (d->um);
         g_debug ("Got %d users\n", g_slist_length (list));
 
         list = g_slist_sort (list, (GCompareFunc) sort_users);
         for (l = list; l; l = l->next) {
                 user = l->data;
                 g_debug ("adding user %s\n", get_real_or_user_name (user));
                 user_added (d->um, user, d);
         }
         g_slist_free (list);
 
-        if (selected_user) {
+        if (um_carousel_get_item_count (d->carousel) == 0)
+                gtk_stack_set_visible_child_name (GTK_STACK (d->stack), PAGE_NO_USERS);
+        if (d->other_accounts == 0)
+                gtk_revealer_set_reveal_child (GTK_REVEALER (d->carousel), FALSE);
+
+        if (selected_user)
                 item = um_carousel_find_item (d->carousel, selected_user, user_compare);
-                um_carousel_select_item (d->carousel, item);
-        }
+        um_carousel_select_item (d->carousel, item);
 
         g_object_set (settings, "gtk-enable-animations", animations, NULL);
 }
 
-static void
-user_removed (ActUserManager *um, ActUser *user, CcUserPanelPrivate *d)
-{
-        gboolean show_carousel;
-
-        d->other_accounts--;
-        show_carousel = (d->other_accounts > 0);
-        gtk_revealer_set_reveal_child (GTK_REVEALER (d->carousel),
-                                       show_carousel);
-
-        reload_users (d, NULL);
-
-        /* Show the current user */
-        user = act_user_manager_get_user_by_id (d->um, getuid ());
-        show_user (user, d);
-}
-
 static gint
 user_compare (gconstpointer i,
               gconstpointer u)
 {
         UmCarouselItem *item;
         ActUser *user;
         gint uid_a, uid_b;
         gint result;
 
         item = (UmCarouselItem *) i;
         user = ACT_USER (u);
 
         uid_a = GPOINTER_TO_INT (g_object_get_data (G_OBJECT (item), "uid"));
         uid_b = act_user_get_uid (user);
 
         result = uid_a - uid_b;
 
         return result;
 }
 
 static void
 user_changed (ActUserManager *um, ActUser *user, CcUserPanelPrivate *d)
 {
-        if (act_user_get_uid (user) != act_user_get_uid (d->selected_user))
-                return;
-
-        reload_users (d, user);
+        reload_users (d, d->selected_user);
 }
 
 static void
 select_created_user (GObject *object,
                      GAsyncResult *result,
                      gpointer user_data)
 {
         CcUserPanelPrivate *d = user_data;
         UmAccountDialog *dialog;
         ActUser *user;
 
         dialog = UM_ACCOUNT_DIALOG (object);
         user = um_account_dialog_finish (dialog, result);
         gtk_widget_destroy (GTK_WIDGET (dialog));
         d->account_dialog = NULL;
 
         if (user == NULL)
                 return;
 
         reload_users (d, user);
 }
 
 static void
 add_user (GtkButton *button, CcUserPanelPrivate *d)
 {
         d->account_dialog = um_account_dialog_new ();
         um_account_dialog_show (d->account_dialog, GTK_WINDOW (gtk_widget_get_toplevel (d->main_box)),
                                 d->permission, select_created_user, d);
 }
 
@@ -1079,89 +1064,84 @@ change_password (GtkButton *button, CcUserPanelPrivate *d)
 static void
 change_fingerprint (GtkButton *button, CcUserPanelPrivate *d)
 {
         GtkWidget *widget;
         ActUser *user;
 
         user = get_selected_user (d);
 
         g_assert (g_strcmp0 (g_get_user_name (), act_user_get_user_name (user)) == 0);
 
         widget = get_widget (d, "account-fingerprint-button");
         fingerprint_button_clicked (GTK_WINDOW (gtk_widget_get_toplevel (d->main_box)), widget, user);
 }
 
 static void
 show_history (GtkButton *button, CcUserPanelPrivate *d)
 {
         ActUser *user;
 
         user = get_selected_user (d);
 
         um_history_dialog_set_user (d->history_dialog, user);
         um_history_dialog_show (d->history_dialog, GTK_WINDOW (gtk_widget_get_toplevel (d->main_box)));
 }
 
 static void
 users_loaded (ActUserManager     *manager,
               GParamSpec         *pspec,
               CcUserPanelPrivate *d)
 {
-        ActUser *user;
         GtkWidget *dialog;
 
         if (act_user_manager_no_service (d->um)) {
                 dialog = gtk_message_dialog_new (GTK_WINDOW (gtk_widget_get_toplevel (d->main_box)),
                                                  GTK_DIALOG_MODAL,
                                                  GTK_MESSAGE_OTHER,
                                                  GTK_BUTTONS_CLOSE,
                                                  _("Failed to contact the accounts service"));
                 gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (dialog),
                                                           _("Please make sure that the AccountService is installed and enabled."));
                 g_signal_connect_swapped (dialog, "response",
                                           G_CALLBACK (gtk_widget_destroy),
                                           dialog);
                 gtk_widget_show (dialog);
 
                 gtk_widget_set_sensitive (d->main_box, FALSE);
         }
 
         g_signal_connect (d->um, "user-changed", G_CALLBACK (user_changed), d);
         g_signal_connect (d->um, "user-is-logged-in-changed", G_CALLBACK (user_changed), d);
         g_signal_connect (d->um, "user-added", G_CALLBACK (user_added), d);
-        g_signal_connect (d->um, "user-removed", G_CALLBACK (user_removed), d);
+        g_signal_connect (d->um, "user-removed", G_CALLBACK (user_changed), d);
 
         reload_users (d, NULL);
-
-        /* Show the current user firstly. */
-        user = act_user_manager_get_user_by_id (d->um, getuid ());
-        show_user (user, d);
 }
 
 static void
 add_unlock_tooltip (GtkWidget *button)
 {
         gchar *names[3];
         GIcon *icon;
 
         names[0] = "changes-allow-symbolic";
         names[1] = "changes-allow";
         names[2] = NULL;
         icon = (GIcon *)g_themed_icon_new_from_names (names, -1);
         setup_tooltip_with_embedded_icon (button,
                                           /* Translator comments:
                                            * We split the line in 2 here to "make it look good", as there's
                                            * no good way to do this in GTK+ for tooltips. See:
                                            * https://bugzilla.gnome.org/show_bug.cgi?id=657168 */
                                           _("To make changes,\nclick the * icon first"),
                                           "*",
                                           icon);
         g_object_unref (icon);
         g_signal_connect (button, "button-release-event",
                            G_CALLBACK (show_tooltip_now), NULL);
 }
 
 static void
 remove_unlock_tooltip (GtkWidget *button)
 {
         setup_tooltip_with_embedded_icon (button, NULL, NULL, NULL);
         g_signal_handlers_disconnect_by_func (button,
-- 
2.14.3

