diff --git a/panels/wacom/cc-wacom-mapping-panel.c b/panels/wacom/cc-wacom-mapping-panel.c
index 3f35816..71a8c17 100644
--- a/panels/wacom/cc-wacom-mapping-panel.c
+++ b/panels/wacom/cc-wacom-mapping-panel.c
@@ -60,7 +60,7 @@ get_rr_outputs (void)
 {
 	GError *error = NULL;
 	GnomeRRScreen *rr_screen;
-	GnomeRRConfig *rr_config;
+	GnomeRRConfig *rr_config = NULL;
 
 	rr_screen = gsd_rr_screen_new (gdk_screen_get_default (), NULL, NULL, &error);
 	if (rr_screen == NULL) {
@@ -165,10 +165,12 @@ update_ui (CcWacomMappingPanel *self)
 		gtk_widget_set_sensitive (GTK_WIDGET(self->priv->checkbutton), FALSE);
 		gtk_toggle_button_set_inconsistent (GTK_TOGGLE_BUTTON(self->priv->checkbutton), TRUE);
 	} else {
-		gboolean is_screen_tablet;
+		GError *error = NULL;
+		gboolean is_screen_tablet, have_xrandr;
 
 		is_screen_tablet = gsd_wacom_device_is_screen_tablet (self->priv->device);
-		gtk_widget_set_sensitive (GTK_WIDGET(self->priv->checkbutton), !is_screen_tablet);
+		have_xrandr = gsd_rr_check_xrandr (gdk_screen_get_default (), &error);
+		gtk_widget_set_sensitive (GTK_WIDGET(self->priv->checkbutton), !have_xrandr || !is_screen_tablet);
 		gtk_toggle_button_set_inconsistent (GTK_TOGGLE_BUTTON(self->priv->checkbutton), FALSE);
 	}
 
diff --git a/panels/wacom/cc-wacom-page.c b/panels/wacom/cc-wacom-page.c
index 0472406..944ec9c 100644
--- a/panels/wacom/cc-wacom-page.c
+++ b/panels/wacom/cc-wacom-page.c
@@ -105,6 +105,32 @@ enum {
 	MODE_RELATIVE, /* stylus + eraser relative */
 };
 
+/* Different types of layout for the tablet config */
+enum {
+	LAYOUT_NORMAL,        /* tracking mode, button mapping */
+	LAYOUT_REVERSIBLE,    /* tracking mode, button mapping, left-hand orientation */
+	LAYOUT_SCREEN        /* button mapping, calibration, display resolution */
+};
+
+static void
+update_tablet_ui (CcWacomPage *page,
+		  int          layout);
+
+static int
+get_layout_type (GsdWacomDevice *device)
+{
+	int layout;
+
+	if (gsd_wacom_device_is_screen_tablet (device))
+		layout = LAYOUT_SCREEN;
+	else if (gsd_wacom_device_reversible (device))
+		layout = LAYOUT_REVERSIBLE;
+	else
+		layout = LAYOUT_NORMAL;
+
+	return layout;
+}
+
 static void
 set_calibration (gint      *cal,
                  gsize      ncal,
@@ -209,8 +235,8 @@ calibrate_button_clicked_cb (GtkButton   *button,
 	gConfValue = gsd_gconf_get (page->priv->wacom_settings_path,
                                 page->priv->wacom_schemas_path,
                                 "area");
-
 	current = gsd_gconf_value_get_int_array (gConfValue, &ncal);
+	gconf_value_free (gConfValue);
 
 	if (!current) {
 		g_warning("Device calibration property not available.\n");
@@ -233,9 +259,11 @@ calibrate_button_clicked_cb (GtkButton   *button,
 	    calibration[3] == -1) {
 		gint *device_cal;
 		device_cal = gsd_wacom_device_get_area (page->priv->stylus);
-		for (i = 0; i < 4; i++)
-			calibration[i] = device_cal[i];
-		g_free (device_cal);
+		if (device_cal) {
+			for (i = 0; i < 4; i++)
+				calibration[i] = device_cal[i];
+			g_free (device_cal);
+		}
 	}
 
 	run_calibration (page, calibration, monitor);
@@ -707,11 +735,14 @@ display_mapping_dialog_closed (GtkDialog   *dialog,
 			       CcWacomPage *page)
 {
 	CcWacomPagePrivate *priv;
+	int layout;
 
 	priv = page->priv;
 	gtk_widget_destroy (priv->dialog);
 	priv->dialog = NULL;
 	priv->mapping = NULL;
+	layout = get_layout_type (priv->stylus);
+	update_tablet_ui (page, layout);
 }
 
 static void
@@ -1045,13 +1076,6 @@ stylus_changed (GsdWacomDevice *device,
 		   gsd_wacom_stylus_get_name (stylus));
 }
 
-/* Different types of layout for the tablet config */
-enum {
-	LAYOUT_NORMAL,        /* tracking mode, button mapping */
-	LAYOUT_REVERSIBLE,    /* tracking mode, button mapping, left-hand orientation */
-	LAYOUT_SCREEN        /* button mapping, calibration, display resolution */
-};
-
 static void
 remove_left_handed (CcWacomPagePrivate *priv)
 {
@@ -1113,14 +1137,19 @@ update_tablet_ui (CcWacomPage *page,
 
 		gtk_widget_destroy (WID ("combo-tabletmode"));
 		gtk_widget_destroy (WID ("label-trackingmode"));
-		gtk_widget_destroy (WID ("display-mapping-button"));
 
 		gtk_widget_show (WID ("button-calibrate"));
-		if (xrandr_supported())
+		if (xrandr_supported()) {
+			gtk_widget_destroy (WID ("display-mapping-button"));
 			gtk_widget_show (WID ("display-link"));
-		else
+		} else
 			remove_display_link (page->priv);
 
+		if (gsd_wacom_device_get_display_monitor (page->priv->stylus) < 0)
+			gtk_widget_set_sensitive (WID ("button-calibrate"), FALSE);
+		else
+			gtk_widget_set_sensitive (WID ("button-calibrate"), TRUE);
+
 		gtk_container_child_set (CWID ("main-grid"),
 					 WID ("tablet-buttons-box"),
 					 "top_attach", 1,
@@ -1172,13 +1201,7 @@ cc_wacom_page_new (CcWacomPanel   *panel,
 	gtk_label_set_text (GTK_LABEL (WID ("label-tabletmodel")), gsd_wacom_device_get_name (stylus));
 
 	/* Type of layout */
-	if (gsd_wacom_device_is_screen_tablet (stylus))
-		layout = LAYOUT_SCREEN;
-	else if (gsd_wacom_device_reversible (stylus))
-		layout = LAYOUT_REVERSIBLE;
-	else
-		layout = LAYOUT_NORMAL;
-
+	layout = get_layout_type (stylus);
 	update_tablet_ui (page, layout);
 
 	/* Left-handedness */
diff --git a/panels/wacom/gsd-wacom-device.c b/panels/wacom/gsd-wacom-device.c
index 503b54c..97f2c00 100644
--- a/panels/wacom/gsd-wacom-device.c
+++ b/panels/wacom/gsd-wacom-device.c
@@ -582,6 +582,46 @@ find_output_by_edid (const gchar *vendor, const gchar *product, const gchar *ser
 }
 
 static GnomeOutputInfo*
+find_single_output (void)
+{
+	GError *error = NULL;
+	GnomeRRScreen *rr_screen = NULL;
+	GnomeRRConfig *rr_config = NULL;
+	GnomeOutputInfo **rr_output_info, **outputs;
+	GnomeOutputInfo *retval = NULL;
+	gint noutputs = 0;
+
+	rr_screen = gsd_rr_screen_new (gdk_screen_get_default (),
+					 NULL, NULL,
+					 &error);
+	if (rr_screen == NULL) {
+		g_warning ("Failed to create GnomeRRScreen: %s", error->message);
+		g_error_free (error);
+	} else
+		rr_config = gnome_rr_config_new_current (rr_screen);
+
+	/* gsd_rr_config_compat_outputs_get() should return something even if rr_config in NULL */
+	rr_output_info = gsd_rr_config_compat_outputs_get (rr_config);
+
+	for (outputs = rr_output_info; *outputs != NULL; outputs++)
+		noutputs++;
+
+	if (noutputs == 1)
+		retval = gsd_rr_compat_output_deep_copy (*rr_output_info);
+
+	gsd_rr_config_compat_outputs_free (rr_output_info);
+	if (rr_config)
+		gnome_rr_config_free (rr_config);
+	if (rr_screen)
+		gnome_rr_screen_destroy (rr_screen);
+
+	if (retval == NULL)
+		g_debug ("More than one monitor found.");
+
+	return retval;
+}
+
+static GnomeOutputInfo*
 find_output_by_heuristic (GsdWacomDevice *device)
 {
 	GnomeOutputInfo *rr_output_info;
@@ -591,6 +631,10 @@ find_output_by_heuristic (GsdWacomDevice *device)
 	 * display tablets are connected.
 	 */
 	rr_output_info = find_output_by_edid("WAC", NULL, NULL);
+
+	if (!rr_output_info)
+		rr_output_info = find_single_output ();
+
 	return rr_output_info;
 }
 
@@ -632,7 +676,7 @@ find_output_by_monitor (GdkScreen *screen,
 {
 	GError *error = NULL;
 	GnomeRRScreen *rr_screen = NULL;
-	GnomeRRConfig *rr_config;
+	GnomeRRConfig *rr_config = NULL;
 	GnomeOutputInfo **rr_output_infos;
 	GnomeOutputInfo *ret;
 	guint i;
@@ -1576,6 +1620,9 @@ gsd_wacom_device_get_area (GsdWacomDevice *device)
 
 	g_return_val_if_fail (GSD_IS_WACOM_DEVICE (device), NULL);
 
+	if (device->priv->device_info == NULL)
+		return NULL;
+
 	id = device->priv->device_info->id;
 
 	area = XInternAtom (GDK_DISPLAY_XDISPLAY (gdk_display_get_default ()), "Wacom Tablet Area", False);
diff --git a/panels/wacom/gsd-wacom-rr-helpers.c b/panels/wacom/gsd-wacom-rr-helpers.c
index ce2906e..240a094 100644
--- a/panels/wacom/gsd-wacom-rr-helpers.c
+++ b/panels/wacom/gsd-wacom-rr-helpers.c
@@ -266,7 +266,7 @@ copy_rr_config_outputs (GnomeRRConfig *configuration)
 {
 	GnomeOutputInfo **outputs = NULL;
 	GnomeOutputInfo **p1, **p2;
-	gsize nitems;
+	gsize nitems = 0;
 
 	g_return_val_if_fail (configuration != NULL, NULL);
 
